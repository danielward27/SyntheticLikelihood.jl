var documenterSearchIndex = {"docs":
[{"location":"simulation_interface/#Simulation-interface","page":"Simulation interface","title":"Simulation interface","text":"","category":"section"},{"location":"simulation_interface/","page":"Simulation interface","title":"Simulation interface","text":"This section describes the structure a simulator should have to work with the package. Simulator functions should take a single positional argument which is a vector of parameters (and can have arbitrary key word arguments). Summary functions should take the output from the simulator directly as a single positional argument (and can have arbitrary key word arguments).","category":"page"},{"location":"simulation_interface/","page":"Simulation interface","title":"Simulation interface","text":"The primary function for carrying out simulations is simulate_n_s, which simulates n sets of summary statistics (or the raw simulator output if no summary is specified).","category":"page"},{"location":"simulation_interface/","page":"Simulation interface","title":"Simulation interface","text":"simulate_n_s","category":"page"},{"location":"simulation_interface/#SyntheticLikelihood.simulate_n_s","page":"Simulation interface","title":"SyntheticLikelihood.simulate_n_s","text":"Simulates summary statistics from the model under a fixed parameter vector. n_sim is specified as the number of simulations. Simulations can be run on multiple threads using parallel = false. By defualt no summary statistic function is used (by passing the identity function).\n\nsimulate_n_s(θ; simulator, summary, n_sim, simulator_kwargs, summary_kwargs, parallel)\n\n\nArguments\n\nθ::AbstractVector Parameter vector passed to simulator.\nsimulator::Function Simulator.\nsummary::Function Summary function that takes output of simulator (defualt identity).\nn_sim::Integer Number of simulations.\nsimulator_kwargs Kwargs passed to simulator.\nsummary_kwargs Kwargs passed to summary.\nparallel::Bool = false Whether to run on multiple threads.\n\n\n\n\n\nAs for above, but a Matrix of parameter values are used, carrying out one     simulation from each row of θ (and hence n_sim is not required).\n\nsimulate_n_s(θ; simulator, summary, simulator_kwargs, summary_kwargs, parallel)\n\n\n\n\n\n\n","category":"function"},{"location":"local_regression/#Local-regression","page":"Local regression","title":"Local regression","text":"","category":"section"},{"location":"local_regression/","page":"Local regression","title":"Local regression","text":"Not yet documented.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SyntheticLikelihood","category":"page"},{"location":"#SyntheticLikelihood","page":"Home","title":"SyntheticLikelihood","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SyntheticLikelihood package. The package is currently a work in progress.","category":"page"},{"location":"samplers/#Samplers","page":"Samplers","title":"Samplers","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"To sample from a distribution, first a sampler object should be created.","category":"page"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"The currently available samplers are shown below:","category":"page"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"Langevin\nPreconditionedLangevin","category":"page"},{"location":"samplers/#SyntheticLikelihood.Langevin","page":"Samplers","title":"SyntheticLikelihood.Langevin","text":"Sampler object for Langevin diffusion. Uses a discrete time Euler approximation of the Langevin diffusion (unadjusted Langevin algorithm), given by the update θ := θ - η/2 * ∇ + ξ, where ξ is given by N(0, ηI).\n\nstep_size\nobjective\ngradient\n\n\n\n\n\n","category":"type"},{"location":"samplers/#SyntheticLikelihood.PreconditionedLangevin","page":"Samplers","title":"SyntheticLikelihood.PreconditionedLangevin","text":"Sampler object for Preconditioned Langevin diffusion. Also can be thought of as     a stochastic newton method. Uses the update:     θ := θ - η/2 * H⁻¹*∇ + ξ, where ξ ∼ N(0, ηH⁻¹).\n\nstep_size\nobjective\ngradient_hessian\n\n\n\n\n\n","category":"type"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"The sampler object defines the hyperparameters of the sampler, the objective function and the gradient/hessian if appropriate. When passing a function (objective/gradient/hessian) to a sampler, it should take a parameter vector θ as its first and only required argument. The aim should be to explore around the minima of the function, so the objective could be the negative log-posterior, for example.","category":"page"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"The sampler object can then passed to run_sampler!, to sample from the distribution:","category":"page"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"run_sampler!","category":"page"},{"location":"samplers/#SyntheticLikelihood.run_sampler!","page":"Samplers","title":"SyntheticLikelihood.run_sampler!","text":"Run the sampling algorithm. Data to collect at each iteration is specified by collect_data, and should be a subset of [:θ, :objective, :gradient, :hessian, :counter].\n\nrun_sampler!(sampler, init_θ, n_steps)\nrun_sampler!(sampler, init_θ, n_steps, collect_data)\n\n\nReturns a tuple, with keys matching collect_data.\n\n\n\n\n\n","category":"function"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"Below is an example to sample from a multivariate normal density using the discretized langevin diffusion (Unadjusted Langevin Algorithm).","category":"page"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"using SyntheticLikelihood, Distributions, Gadfly\n\n# Sample from MVN\nd = MvNormal([10 5; 5 10])\nobjective(θ) = -logpdf(d, θ)\ngradient(θ) = -gradlogpdf(d, θ)\ninit_θ = [-15., -15]\nn_steps = 1000\n\nlangevin = Langevin(;step_size = 1., objective, gradient)\ndata = run_sampler!(langevin, init_θ, n_steps, [:θ, :counter])\n\nθ_samples = data[:θ]\nx = y = range(-20, 20; length=50)\n\ncontours = layer(z = (x, y) -> logpdf(d, [x,y]), x = x, y = y, Geom.contour)\npoints = layer(x = θ_samples[:,1], y = θ_samples[:,2], Geom.point,\n                Theme(alphas=[0.2], default_color = \"black\"))\n\nplot(contours, points)","category":"page"},{"location":"samplers/#Implementation-details","page":"Samplers","title":"Implementation details","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"To implement a new sampler, each sampler must:","category":"page"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"Be a subtype of AbstractSampler.\nHave a get_init_state method, which returns a SamplerState object given init_θ e.g. with signature get_init_state(sampler::MySampler, init_θ::Vector{Float64}).\nHave an update! method, taking the sampler and the SamplerState object update!(sampler::MySampler, state::SamplerState). This updates the state (parameters, gradients etc, and sampler object if applicable).","category":"page"}]
}
