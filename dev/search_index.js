var documenterSearchIndex = {"docs":
[{"location":"simulation_interface/#Simulation-interface","page":"Simulation interface","title":"Simulation interface","text":"","category":"section"},{"location":"simulation_interface/","page":"Simulation interface","title":"Simulation interface","text":"This section describes the structure a simulator should have to work with the package. Simulator functions should take a single positional argument which is a vector of parameters (and can have arbitrary key word arguments). Summary functions should take the output from the simulator directly as a single positional argument (and can have arbitrary key word arguments).","category":"page"},{"location":"simulation_interface/","page":"Simulation interface","title":"Simulation interface","text":"The primary function for carrying out simulations is simulate_n_s, which simulates n sets of summary statistics (or the raw simulator output if no summary is specified).","category":"page"},{"location":"simulation_interface/","page":"Simulation interface","title":"Simulation interface","text":"simulate_n_s","category":"page"},{"location":"simulation_interface/#SyntheticLikelihood.simulate_n_s","page":"Simulation interface","title":"SyntheticLikelihood.simulate_n_s","text":"Simulates summary statistics from the model under a fixed parameter vector. n_sim is specified as the number of simulations. Simulations can be run on multiple threads using parallel = false. By defualt no summary statistic function is used (by passing the identity function).\n\nsimulate_n_s(θ; simulator, summary, n_sim, simulator_kwargs, summary_kwargs, parallel)\n\n\nArguments\n\nθ::AbstractVector Parameter vector passed to simulator.\nsimulator::Function Simulator.\nsummary::Function Summary function that takes output of simulator (defualt identity).\nn_sim::Integer Number of simulations.\nsimulator_kwargs Kwargs passed to simulator.\nsummary_kwargs Kwargs passed to summary.\nparallel::Bool = false Whether to run on multiple threads.\n\n\n\n\n\nAs for above, but a Matrix of parameter values are used, carrying out one     simulation from each row of θ (and hence n_sim is not required).\n\nsimulate_n_s(θ; simulator, summary, simulator_kwargs, summary_kwargs, parallel)\n\n\n\n\n\n\n","category":"function"},{"location":"local_regression/#Local-regression","page":"Local regression","title":"Local regression","text":"","category":"section"},{"location":"local_regression/","page":"Local regression","title":"Local regression","text":"Not yet documented.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SyntheticLikelihood","category":"page"},{"location":"#SyntheticLikelihood","page":"Home","title":"SyntheticLikelihood","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SyntheticLikelihood package. The package is currently a work in progress.","category":"page"},{"location":"samplers/#Samplers","page":"Samplers","title":"Samplers","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"To sample from a distribution, first a sampler object should be created.","category":"page"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"The currently available samplers are shown below:","category":"page"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"Langevin\nPreconditionedLangevin","category":"page"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"This defines the hyperparameters of the sampler, the objective function and the gradient/hessian if appropriate. When passing a function (objective/gradient/hessian) to a sampler, it should take a parameter vector θ as its first and only required argument. The aim should be to explore around the minima of the function, so the objective could be the negative log-posterior, for example.","category":"page"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"The sampler object can then passed to run_sampler!, to sample from the distribution:","category":"page"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"run_sampler!","category":"page"},{"location":"samplers/#SyntheticLikelihood.run_sampler!","page":"Samplers","title":"SyntheticLikelihood.run_sampler!","text":"Run the sampling algorithm. Data to collect at each iteration is specified by collect_data, and should be a subset of [:θ, :objective, :gradient, :hessian, :counter].\n\nrun_sampler!(sampler, init_θ, n_steps)\nrun_sampler!(sampler, init_θ, n_steps, collect_data)\n\n\nReturns a tuple, with keys matching collect_data.\n\n\n\n\n\n","category":"function"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"Below is an example to sample from a multivariate normal density using the discretized langevin diffusion (Unadjusted Langevin Algorithm).","category":"page"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"using SyntheticLikelihood, Distributions, Gadfly\n\n# Sample from MVN\nd = MvNormal([10 5; 5 10])\nobjective(θ) = -logpdf(d, θ)\ngradient(θ) = -gradlogpdf(d, θ)\ninit_θ = [-15., -15]\nn_steps = 1000\n\nlangevin = Langevin(;step_size = 1., objective, gradient)\ndata = run_sampler!(langevin, init_θ, n_steps, [:θ, :counter])\n\nθ_samples = data[:θ]\nx = y = range(-20, 20; length=50)\n\ncontours = layer(z = (x, y) -> logpdf(d, [x,y]), x = x, y = y, Geom.contour)\npoints = layer(x = θ_samples[:,1], y = θ_samples[:,2], Geom.point,\n                Theme(alphas=[0.2], default_color = \"black\"))\n\nplot(contours, points)","category":"page"},{"location":"samplers/#Implementation-details","page":"Samplers","title":"Implementation details","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"To implement a new sampler, each sampler must:","category":"page"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"Be a subtype of AbstractSampler.\nHave a get_init_state method, which returns a SamplerState object given init_θ e.g. with signature get_init_state(sampler::MySampler, init_θ::Vector{Float64}).\nHave an update! method, taking the sampler and the SamplerState object update!(sampler::MySampler, state::SamplerState). This updates the state (parameters, gradients etc, and sampler object if applicable).","category":"page"},{"location":"full_function_list/#Full-function-list","page":"All functions","title":"Full function list","text":"","category":"section"},{"location":"full_function_list/","page":"All functions","title":"All functions","text":"The full list of documented functions are shown below. Note, some may not be exported, so would have to accessed using the syntax SyntheticLikelihood.my_func.","category":"page"},{"location":"full_function_list/#Function-list","page":"All functions","title":"Function list","text":"","category":"section"},{"location":"full_function_list/","page":"All functions","title":"All functions","text":"","category":"page"},{"location":"full_function_list/#Function-descriptions","page":"All functions","title":"Function descriptions","text":"","category":"section"},{"location":"full_function_list/","page":"All functions","title":"All functions","text":"Modules = [SyntheticLikelihood]","category":"page"},{"location":"full_function_list/#SyntheticLikelihood.Langevin","page":"All functions","title":"SyntheticLikelihood.Langevin","text":"Sampler object for Langevin diffusion. Uses a discrete time Euler approximation of the Langevin diffusion (unadjusted Langevin algorithm), given by the update θ := θ - η/2 * ∇ + ξ, where ξ is given by N(0, ηI).\n\n\n\n\n\n","category":"type"},{"location":"full_function_list/#SyntheticLikelihood.LocalΣ","page":"All functions","title":"SyntheticLikelihood.LocalΣ","text":"Struct that contains the estimated local properties of Σ (the covariance matrix of the summary statistics).\n\nFields\n\nΣ The (nₛ×nₛ) (estimated) covariance matrix of the summary statistics.\n∂ The (nₛ×nₛ×n_θ) matrix of estimated first derivitives of Σ.\n\n\n\n\n\n","category":"type"},{"location":"full_function_list/#SyntheticLikelihood.Localμ","page":"All functions","title":"SyntheticLikelihood.Localμ","text":"Struct that contains the estimated local properties of μ.\n\nFields\n\nμ::Float64 Mean of the summary statistic.\n∂::Vector{Float64} First derivitive w.r.t. parameters.\n∂²::Matrix{Float64} Second derivitive w.r.t. parameters.\nϵ::Vector{Float64} Residuals.\n\n\n\n\n\n","category":"type"},{"location":"full_function_list/#SyntheticLikelihood.PreconditionedLangevin","page":"All functions","title":"SyntheticLikelihood.PreconditionedLangevin","text":"Sampler object for Preconditioned Langevin diffusion. Also can be thought of as     a stochastic newton method. Uses the update:     θ := θ - η/2 * H⁻¹*∇ + ξ, where ξ ∼ N(0, ηH⁻¹).\n\n\n\n\n\n","category":"type"},{"location":"full_function_list/#SyntheticLikelihood.SamplerState","page":"All functions","title":"SyntheticLikelihood.SamplerState","text":"Struct for containing the state of sampler at a particular iteration.     Gradient and hessian are missing unless specified.\n\n\n\n\n\n","category":"type"},{"location":"full_function_list/#SyntheticLikelihood.add_state!-Tuple{NamedTuple,SyntheticLikelihood.SamplerState,Integer}","page":"All functions","title":"SyntheticLikelihood.add_state!","text":"Add data to the data tuple.\n\n\n\n\n\n","category":"method"},{"location":"full_function_list/#SyntheticLikelihood.get_residuals-Tuple{Array{Localμ,1}}","page":"All functions","title":"SyntheticLikelihood.get_residuals","text":"Get an array of residuals from a vector of Localμ structs. Returns (length of residuals × number of summary stats) matrix\n\n\n\n\n\n","category":"method"},{"location":"full_function_list/#SyntheticLikelihood.glm_local_Σ-Tuple{}","page":"All functions","title":"SyntheticLikelihood.glm_local_Σ","text":"Use a gamma distributed GLM with log link function to estimate the local properties     of Σ. θ should not have a bias term (added internally).\n\nSpecifically, this function:\n\nCreates a rough initial Σ estimate using cov(ϵ).\nEstimates the diagonal elements of Σ, and ∂Σⱼⱼ using local regression.\n\nArguments\n\nθ_orig::AbstractVector  Original θ (used for centering).\nθ::AbstractMatrix Peturbed θ from local area.\nϵ::AbstractMatrix Residuals from quadratic regression (nsim × nsumstats).\n\n\n\n\n\n","category":"method"},{"location":"full_function_list/#SyntheticLikelihood.init_data_tuple-Tuple{SyntheticLikelihood.SamplerState,Array{Symbol,1},Integer}","page":"All functions","title":"SyntheticLikelihood.init_data_tuple","text":"Function initialises a named tuple containing Vectors with undefined values. Used with samplers to store results. State just provides an \"example\" state from which to infer types of vectors in the array. Names of the named tuple are the symbols provided.\n\n\n\n\n\n","category":"method"},{"location":"full_function_list/#SyntheticLikelihood.linear_regression-Tuple{AbstractArray{T,2} where T,AbstractArray{T,1} where T}","page":"All functions","title":"SyntheticLikelihood.linear_regression","text":"Carry out linear regression. X should have a bias column. Returns tuple (β, ŷ).\n\nlinear_regression(X, y)\n\n\n\n\n\n\n","category":"method"},{"location":"full_function_list/#SyntheticLikelihood.pairwise_combinations-Tuple{Integer}","page":"All functions","title":"SyntheticLikelihood.pairwise_combinations","text":"Pairwise combinations (for quadratic regression). n=5 would return all the pairwise combinations between 1:5 (including matched terms e.g. [1,1]).\n\npairwise_combinations(n)\n\n\n\n\n\n\n","category":"method"},{"location":"full_function_list/#SyntheticLikelihood.peturb","page":"All functions","title":"SyntheticLikelihood.peturb","text":"Peturb a vector using a user specified distribution (often MVN zero mean). Returns array of size (n, length(θ))\n\npeturb(θ, d)\npeturb(θ, d, n)\n\n\nArguments\n\nθ::AbstractVector Parameter to peturb.\nd::Sampleable Distribution from which to sample (see Distributions.jl).\nn::Integer = 1 Number of peturbed vectors to return.\n\n\n\n\n\n","category":"function"},{"location":"full_function_list/#SyntheticLikelihood.quadratic_design_matrix-Tuple{AbstractArray{T,2} where T}","page":"All functions","title":"SyntheticLikelihood.quadratic_design_matrix","text":"Design matrix for quadratic regression. Bias term appended as first column internally. Returns a tuple, with the matrix and the corresponding indices multiplied, that give rise to each column. Note, indices [1, 1] corresponds to the bias term (so indices compared to original matrix is shifted).\n\nquadratic_design_matrix(X)\n\n\n\n\n\n\n","category":"method"},{"location":"full_function_list/#SyntheticLikelihood.quadratic_local_μ-Tuple{}","page":"All functions","title":"SyntheticLikelihood.quadratic_local_μ","text":"Finds the local behaviour of the summary statistic mean μ. Uses quadratic linear regression to approximate the mean, gradient and hessian around θ_orig. Returns a vector of Localμ structs (see above), with length equal to the number of summary statistics.\n\nquadratic_local_μ(; θ_orig, θ, s)\n\n\nArguments\n\nθ_orig::AbstractVector Original θ.\nθ::AbstractMatrix Peturbed θ (sampled from local area).\ns::AbstractMatrix Corresponding summary statistics to θ.\n\n\n\n\n\n","category":"method"},{"location":"full_function_list/#SyntheticLikelihood.run_sampler!","page":"All functions","title":"SyntheticLikelihood.run_sampler!","text":"Run the sampling algorithm. Data to collect at each iteration is specified by collect_data, and should be a subset of [:θ, :objective, :gradient, :hessian, :counter].\n\nrun_sampler!(sampler, init_θ, n_steps)\nrun_sampler!(sampler, init_θ, n_steps, collect_data)\n\n\nReturns a tuple, with keys matching collect_data.\n\n\n\n\n\n","category":"function"},{"location":"full_function_list/#SyntheticLikelihood.simplify_data-Tuple{NamedTuple}","page":"All functions","title":"SyntheticLikelihood.simplify_data","text":"Loop through named tuple and call stack_arrays on any vector whose elements are an array. Used at end of samplers.\n\n\n\n\n\n","category":"method"},{"location":"full_function_list/#SyntheticLikelihood.simulate_n_s-Tuple{AbstractArray{T,1} where T}","page":"All functions","title":"SyntheticLikelihood.simulate_n_s","text":"Simulates summary statistics from the model under a fixed parameter vector. n_sim is specified as the number of simulations. Simulations can be run on multiple threads using parallel = false. By defualt no summary statistic function is used (by passing the identity function).\n\nsimulate_n_s(θ; simulator, summary, n_sim, simulator_kwargs, summary_kwargs, parallel)\n\n\nArguments\n\nθ::AbstractVector Parameter vector passed to simulator.\nsimulator::Function Simulator.\nsummary::Function Summary function that takes output of simulator (defualt identity).\nn_sim::Integer Number of simulations.\nsimulator_kwargs Kwargs passed to simulator.\nsummary_kwargs Kwargs passed to summary.\nparallel::Bool = false Whether to run on multiple threads.\n\n\n\n\n\n","category":"method"},{"location":"full_function_list/#SyntheticLikelihood.simulate_n_s-Tuple{AbstractArray{T,2} where T}","page":"All functions","title":"SyntheticLikelihood.simulate_n_s","text":"As for above, but a Matrix of parameter values are used, carrying out one     simulation from each row of θ (and hence n_sim is not required).\n\nsimulate_n_s(θ; simulator, summary, simulator_kwargs, summary_kwargs, parallel)\n\n\n\n\n\n\n","category":"method"},{"location":"full_function_list/#SyntheticLikelihood.stack_arrays-Tuple{Array{T,1} where T}","page":"All functions","title":"SyntheticLikelihood.stack_arrays","text":"Stacks a vector of consitently sized arrays to make a new array with dimensions (length(x), dim(x[1])...).\n\n\n\n\n\n","category":"method"},{"location":"full_function_list/#SyntheticLikelihood.synthetic_likelihood-Tuple{AbstractArray{T,1} where T}","page":"All functions","title":"SyntheticLikelihood.synthetic_likelihood","text":"Evaluates synthetic likelhood of observed data for a fixed parameter vector     using a multivariate Gaussian assumption as in (Simon Wood, 2010).\n\nsynthetic_likelihood(θ; simulator, summary, s_true, n_sim, simulator_kwargs, summary_kwargs)\n\n\nArguments\n\nθ::AbstractVector Parameter vector passed to simulator.\nsimulator::Function Simulator.\nsummary::Function Summary function that takes output of simulator (defualt identity).\ns_true::AbstractVector Observed summary statistics.\nn_sim::Integer Number of simulations to use.\nsimulator_kwargs Kwargs splatted in simulator.\nsummary_kwargs Kwargs splatted in summary.\n\n\n\n\n\n","category":"method"}]
}
