<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example · SyntheticLikelihood.jl</title><link rel="canonical" href="https://danielward27.github.io/SyntheticLikelihood.jl/example/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SyntheticLikelihood.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Example</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#We-can-plot-the-correlation-structure-with-StatsPlots.jl:"><span>We can plot the correlation structure with StatsPlots.jl:</span></a></li></ul></li><li><a class="tocitem" href="../documentation/">Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h1><p>To see how things work, its easiest to consider an example. Here we consider the simulating from the noisily observed ricker map.</p><h3 id="Imports"><a class="docs-heading-anchor" href="#Imports">Imports</a><a id="Imports-1"></a><a class="docs-heading-anchor-permalink" href="#Imports" title="Permalink"></a></h3><pre><code class="language-julia">using SyntheticLikelihood, Distributions, StatsPlots, StatsBase, Random
Random.seed!(1)</code></pre><h3 id="Define-the-simulator"><a class="docs-heading-anchor" href="#Define-the-simulator">Define the simulator</a><a id="Define-the-simulator-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-simulator" title="Permalink"></a></h3><p>The simulator should take a vector of parameters.</p><pre><code class="language-julia">function ricker(r, ϕ, σ; init_n=5, n_iters=200, nburn=50)
  ϵ = randn(n_iters)*σ
  nₜ = init_n

  x = Vector{Int}(undef, n_iters)
  for i in 1:n_iters
    x[i]  = rand(Poisson(ϕ*nₜ))
    nₜ = r*nₜ*exp(-nₜ + ϵ[i])
  end
  x[nburn+1:n_iters]
end</code></pre><pre class="documenter-example-output">ricker (generic function with 1 method)</pre><p>Make parameter input a vector:</p><pre><code class="language-julia">ricker(θ::Vector{Float64}) = ricker(θ...)</code></pre><h3 id="Summary-function"><a class="docs-heading-anchor" href="#Summary-function">Summary function</a><a id="Summary-function-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-function" title="Permalink"></a></h3><p>If no summary statistic function is used, then the summary defualts to the identity. However, a summary function can be specified that summarises the output of the simulator in to a vector.</p><pre><code class="language-julia">function ricker_summary(x)
    if all(x.==0)
      return [0., 0., length(x), 0, 0, 0, 0]
    else
      s = [mean(x[x.&gt;0]),
        median(x[x.&gt;0]),
        sum(x.==0),
        sum(x.&gt;10),
        autocov(x, [1, 2, 3])...]
      return s
    end
  end</code></pre><h3 id="Ground-truth"><a class="docs-heading-anchor" href="#Ground-truth">Ground truth</a><a id="Ground-truth-1"></a><a class="docs-heading-anchor-permalink" href="#Ground-truth" title="Permalink"></a></h3><p>As this is a toy example, we will generate &quot;true&quot; parameters, alongside a &quot;pseudo-observed&quot; simulated dataset.</p><pre><code class="language-julia">θ_true = [6, 1, 0.6]
x_true = ricker(θ_true)
s_true = ricker_summary(x_true)</code></pre><h3 id="The-prior"><a class="docs-heading-anchor" href="#The-prior">The prior</a><a id="The-prior-1"></a><a class="docs-heading-anchor-permalink" href="#The-prior" title="Permalink"></a></h3><p>Priors can either be multivariate distribution or be specified as a <code>Product</code> distribution (for independent priors for each parameter), in either case using <a href="https://juliastats.org/Distributions.jl/stable/"><code>Distributions.jl</code></a> Below a <code>Product</code> distribution is used.</p><pre><code class="language-julia">prior = Product([LogNormal(2, 0.4), Uniform(0, 5), Uniform(0, 5)])</code></pre><h3 id="LocalPosterior"><a class="docs-heading-anchor" href="#LocalPosterior"><code>LocalPosterior</code></a><a id="LocalPosterior-1"></a><a class="docs-heading-anchor-permalink" href="#LocalPosterior" title="Permalink"></a></h3><p>The local regression MCMC technique estimates the gradient and Hessian of the likelihood at each iteration. To achieve this rather than carrying out many simulations at a single parameter value to estimate the likelihood (as in standard synthetic likelihood), many simulations from a &quot;local&quot; area around the current θ value must be used. One can sample parameters consistent with the data using <a href="../documentation/#SyntheticLikelihood.LocalLikelihood"><code>LocalLikelihood</code></a>. However here we consider Bayesian inference, so will use <a href="../documentation/#SyntheticLikelihood.LocalPosterior"><code>LocalPosterior</code></a>. This interanally uses <a href="../documentation/#SyntheticLikelihood.LocalLikelihood"><code>LocalLikelihood</code></a> to estimate the the gradient and Hessian of the likelihood as before, and then uses automatic differentiation of the prior to get the gradient and Hessian of the prior. These can then be used to calculcate the gradient and Hessian of the posterior.</p><pre><code class="language-julia">local_posterior = LocalPosterior(;
  simulator = ricker,
  summary = ricker_summary,
  s_true,
  n_sim = 1000,
  prior,
)</code></pre><p>The above object describes how we want to estimate the posterior at each step in the sampler. The other important parameter <code>P</code> is the initial proposal distribution. This is what is used to generate <code>n_sim</code> peturbed parameters to make the local regressions possible (we require variance in the parameters). This parameter isn&#39;t shown as it is left to the default (inferred from the prior). The proposal adapts based on the Hessian estimate at each iteration.</p><h3 id="The-sampler"><a class="docs-heading-anchor" href="#The-sampler">The sampler</a><a id="The-sampler-1"></a><a class="docs-heading-anchor-permalink" href="#The-sampler" title="Permalink"></a></h3><p>We can then sample from the posterior. Below I will use the Riemannian Unadjusted Langevin sampler (<a href="../documentation/#SyntheticLikelihood.RiemannianULA"><code>RiemannianULA</code></a>) with a step size of 0.1. A rough explanation of this sampler is that it uses a Newton update, and adds some noise at each iteration.</p><pre><code class="language-">rula = RiemannianULA(0.1)
init_θ = [8, 4, 0.1]
n_steps = 2000
data = run_sampler!(rula, local_posterior; init_θ, n_steps)</code></pre><h3 id="Plotting-the-results"><a class="docs-heading-anchor" href="#Plotting-the-results">Plotting the results</a><a id="Plotting-the-results-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-the-results" title="Permalink"></a></h3><p>StatsPlots.jl provides most the tools required for plotting results.</p><pre><code class="language-">θ_names = [&quot;r&quot; &quot;ϕ&quot; &quot;σ&quot;]
plot(data.θ, layout = 3, xlabel = θ_names, labels = false)</code></pre><p>We can remove the burn in and plot the marginal densities. SyntheticLikelihood.jl provides <a href="../documentation/#SyntheticLikelihood.plot_prior_posterior_density-Tuple{Distributions.Product, AbstractMatrix{T} where T}"><code>plot_prior_posterior_density</code></a> to achieve this simply.</p><pre><code class="language-">samples = data.θ[1001:end, :]
plot_prior_posterior_density(
  prior, samples, θ_true; θ_names
)</code></pre><h1 id="We-can-plot-the-correlation-structure-with-StatsPlots.jl:"><a class="docs-heading-anchor" href="#We-can-plot-the-correlation-structure-with-StatsPlots.jl:">We can plot the correlation structure with StatsPlots.jl:</a><a id="We-can-plot-the-correlation-structure-with-StatsPlots.jl:-1"></a><a class="docs-heading-anchor-permalink" href="#We-can-plot-the-correlation-structure-with-StatsPlots.jl:" title="Permalink"></a></h1><pre><code class="language-">corrplot(samples, labels = θ_names)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../documentation/">Documentation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 20 April 2021 09:18">Tuesday 20 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
